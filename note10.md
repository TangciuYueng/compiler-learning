[TOC]
# 代码优化
不同的优化
- 对中间代码的优化对于前端，主要讲的
- 对目标代码的优化对于后端

早期编译程序的不足
- 目标程序质量差
- 运行时间长

优化：对程序进行各种等价变换，使得从变换后的程序出发，能生成更有效的目标代码

## 概述
### 原则
- 等价原则：经过优化后的代码不应该改变程序运行的结果
- 有效原则：使得优化后所产生的目标代码运行时间较短，占用存储空间较小
- 合算原则：应该尽可能以较低的代价取得较好的优化效果

### 级别
- 局部
- 循环
- 全局

### 种类
- 删除多余运算（删除公用子表达式/寻找公共子表达式）
- 复写传播
- 删除无用赋值
- 代码外提
- 强度削弱
- 变换循环控制条件
- 合并已知量

## 示例
### 删除公共子表达式
别人算过的就直接拿来用，不用再算一遍

$T_6:=4*i$
$T_7:=4*i$

变为
$T_6:=4*i$
$T_7:=T_6$

### 复写传播
目的是得出多余的表达式

$T_6:=T_2$
$x:=a[T_6]$
$T_7:=T_6$
$T_9:=a[T_7]$

变为

$T_6:=T_2$
$x:=a[T_2]$
$T_7:=T_2$
$T_9:=a[T_2]$

### 删除无用赋值/无用代码
把后面没有用到的删掉
一般删掉的是临时变量

$T_6:=T_2$
$x:=a[T_2]$
$T_7:=T_2$
$T_9:=a[T_2]$

变为

$T_9:=a[T_2]$

#### 强度削弱
乘法运算的归纳变量乘法变成加减法

$B_3$
$j:=j-1$(基础归纳变量，控制循环的)
$T_4:=4*j$(和基础归纳变量有线性关系叫做归纳变量)
$T_5:=a[T_4]$
$if T_5 > v goto B_3$

变为

$T_4:=T_4 - 4$

注意在循环外边要提前用$j$赋值$T_4$

### 删除归纳变量
更多是删除基础归纳变量
经过强度削弱了之后，基础归纳变量的作用就仅仅是控制循环了

$j:=j-1$
$T_4:=T_4 - 4$
$T_5:=a[T_4]$
$if T_5 > v goto B_3$

变为

$T_4:=T_4 - 4$
$T_5:=a[T_4]$
$if T_5 > v goto B_3$

### 代码外提
循环中的不变的语句提出到外面

## 局部优化

### 基本快
基本块：指程序中一顺序执行语句序列，其中只有**一个入口和一个出口**。入口就是其中第一个语句，出口就是其中最后一个语句。

如果一条三地址语句为x:=y+z，则称对x定值并引用y和z。

在一个基本块中的一个名字，所谓在程序中的某个给定点是活跃的，是指如果在程序中(包括在本基本块或在其它基本块中)它的值在该点以后被引用。

### 划分基本快

求出四元式程序中各个基本快的入口语句
- 程序的**第一个**语句
- 能由**条件**转移语句或**无条件**转移语句转移到的语句
- 紧跟在**条件**转移语句后面的语句
  - 无条件转移之后的语句可能永远也执行不到

三种情况
- 入口->下一个入口的上面一条
- 入口->转移语句
- 入口->停止语句

凡是没有被纳入基本块的语句可以删除了

用线连起来就是一个流图了

### 优化措施
- 合并已知量$T_1:=2 \dotsb T_2:=4*T_1$ 编程 $T_2:=8$
- 临时变量改名
- 交换语句位置
- 代数变换
  - 删除$x:=x+0$、$x:=x*1$
  - $x:=y**2$变成$x:=y*y$

## 基本快的DAG表示
0、1、2型代码

## 循环优化
- 代码外提
- 强度削弱
- 删除归纳变量

### 代码外提
循环不变运算才能外提
对四元式`A:=B op C`，若B和C是常数，或这到达他们的B和C的定值点都在循环外

有些循环不变运算不能外提

#### 对于S(A:=B OP C)外提条件
- 不变运算所在的结点是L所有**出口结点的必经结点**，出循环后**不再引用I的值**，即使不在必经结点内也可以考虑外移
- A在循环中**其他地方未再定值**，才能把循环不变运算A:=B op C外提
- 循环中所有A的引用点只有S中的A的定值才能到达。

并不是说把所有的优化都要做全，而是首先不能改变代码逻辑，做主要的优化即可

#### 查找循环L的不变运算算法
1. 一次查看L中各基本块的每个四元式，如果它的每个运算对象或为常数，或者定值点在L外，则将此四元式标记为不变运算
2. 重复第三步直至没有新的四元式被标记为不变运算为止
3. 一次查看尚未被标记的不变运算的四元式，如果它的每个运算对象或为常数，或定值点在L之外，或只有一个到达定值点且该点上的四元式已经被标记为不变运算，则把被查看的四元式标记为不变运算

#### 外码外提算法
1. 求出L的所有不变运算
2. 对每个不变运算s: A := B op C 或 A := op B 或 A := B 检查是否满足条件(1)或(2)
  (1)
    i. s所在的节点是L所有出口节点的必经节点
    ii. A在L中其他地方未定值
    iii. L中所有A的引用点只有s中的A的定值才能到达
  (2)
    A在离开L之后不再是活跃的，并且条件(1)的ii和iii成立。所谓A在离开L后不是活跃的是指A在L的任何出口节点的后继节点的入口处不是活跃的
3. 按步骤1所找出的不变运算的次序，一次把符合条件2的条件(1)或(2)的不变运算s外提到L的前置节点中，但是如果s的运算对象是在L中定值的，那么只有当这些定值四元式都已提到前置节点中时，才能把s也提到前直节点中

只后两点，只要外面不用了就不管第一个条件了

### 强度削弱
把程序中执行时间较长的运算转换为执行时间较短的运算
- 归纳变量乘法的变成递归加减法

如果循环中对变量I只有唯一的形如I:=I±C的赋值，且其中C为循环不变量，则称I为循环中的基本归纳变量。

如果I是循环中一基本归纳变量，J在循环中的定
值总是可化归为I的同一线性函数，也即J=C1*I ±C2，其中C1和C2都是循环不变量，则称J是归纳变量，并称它与I同族

一个基本归纳变量也是归纳变量

每一个归纳变量都要强度削弱

#### 算法
1. 利用循环不变运算信息，找出循环中所有基本归纳变量。
2. 找出所有其它归纳变量A，并找出A与已知基本归纳变量X的同族线性函数关系 FA(X)。
3. 对2中找出的每一归纳变量A，进行强度削弱。
4. 删除对归纳变量的无用赋值。
5. 删除基本归纳变量: 如果基本归纳变量B在循环出口之后不是活跃的，并且在循环中，除在其自身的递归赋值中被引用外，只在形如 if B rop Y goto L 中被引用，则可选取一与B同族的归纳变量M来替换B进行条件控制。最后删除循环中对B的递归赋值的代码。

#### 总结
- 强度削弱主要是针对与基本归纳变量有线性关系的归纳变量的赋值运算进行；
- 经过强度削弱后，循环中可能出现一些新的无用赋值，可以删除；
- 对于基础归纳变量，也可以进一步删除；
- 对于削弱下标变量地址计算的强度非常有效