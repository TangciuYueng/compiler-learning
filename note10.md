[TOC]
# 代码优化
不同的优化
- 对中间代码的优化对于前端，主要讲的
- 对目标代码的优化对于后端

早期编译程序的不足
- 目标程序质量差
- 运行时间长

优化：对程序进行各种等价变换，使得从变换后的程序出发，能生成更有效的目标代码

## 概述
### 原则
- 等价原则：经过优化后的代码不应该改变程序运行的结果
- 有效原则：使得优化后所产生的目标代码运行时间较短，占用存储空间较小
- 合算原则：应该尽可能以较低的代价取得较好的优化效果

### 级别
- 局部
- 循环
- 全局

### 种类
- 删除多余运算（删除公用子表达式/寻找公共子表达式）
- 复写传播
- 删除无用赋值
- 代码外提
- 强度削弱
- 变换循环控制条件
- 合并已知量

## 示例
### 删除公共子表达式
别人算过的就直接拿来用，不用再算一遍

$T_6:=4*i$
$T_7:=4*i$

变为
$T_6:=4*i$
$T_7:=T_6$

### 复写传播
目的是得出多余的表达式

$T_6:=T_2$
$x:=a[T_6]$
$T_7:=T_6$
$T_9:=a[T_7]$

变为

$T_6:=T_2$
$x:=a[T_2]$
$T_7:=T_2$
$T_9:=a[T_2]$

### 删除无用赋值/无用代码
把后面没有用到的删掉
一般删掉的是临时变量

$T_6:=T_2$
$x:=a[T_2]$
$T_7:=T_2$
$T_9:=a[T_2]$

变为

$T_9:=a[T_2]$

#### 强度削弱
乘法运算的归纳变量乘法变成加减法

$B_3$
$j:=j-1$(基础归纳变量，控制循环的)
$T_4:=4*j$(和基础归纳变量有线性关系叫做归纳变量)
$T_5:=a[T_4]$
$if T_5 > v goto B_3$

变为

$T_4:=T_4 - 4$

注意在循环外边要提前用$j$赋值$T_4$

### 删除归纳变量
更多是删除基础归纳变量
经过强度削弱了之后，基础归纳变量的作用就仅仅是控制循环了

$j:=j-1$
$T_4:=T_4 - 4$
$T_5:=a[T_4]$
$if T_5 > v goto B_3$

变为

$T_4:=T_4 - 4$
$T_5:=a[T_4]$
$if T_5 > v goto B_3$

### 代码外提
循环中的不变的语句提出到外面

## 局部优化

### 基本快
基本块：指程序中一顺序执行语句序列，其中只有**一个入口和一个出口**。入口就是其中第一个语句，出口就是其中最后一个语句。

如果一条三地址语句为x:=y+z，则称对x定值并引用y和z。

在一个基本块中的一个名字，所谓在程序中的某个给定点是活跃的，是指如果在程序中(包括在本基本块或在其它基本块中)它的值在该点以后被引用。

### 划分基本快

求出四元式程序中各个基本快的入口语句
- 程序的**第一个**语句
- 能由**条件**转移语句或**无条件**转移语句转移到的语句
- 紧跟在**条件**转移语句后面的语句
  - 无条件转移之后的语句可能永远也执行不到

三种情况
- 入口->下一个入口的上面一条
- 入口->转移语句
- 入口->停止语句

凡是没有被纳入基本块的语句可以删除了

用线连起来就是一个流图了

### 优化措施
- 合并已知量$T_1:=2 \dotsb T_2:=4*T_1$ 编程 $T_2:=8$
- 临时变量改名
- 交换语句位置
- 代数变换
  - 删除$x:=x+0$、$x:=x*1$
  - $x:=y**2$变成$x:=y*y$

## 基本快的DAG表示
0、1、2型代码

## 循环优化
- 代码外提
- 强度削弱
- 删除归纳变量

### 代码外提
循环不变运算才能外提

有些循环不变运算不能外提