[TOC]
# 语义分析与中间代码产生
本章主打一个看书，P190附近的操作就好

![](./ref/note7-1.PNG)

静态语义检查
- 类型检查
- 控制流检查
- 一致性检查
- 相关名字检查
- 名字的作用域分析

## 中间语言
中间语言(复杂性介于源语言和目标语言之间)好处
- 便于进行与及其无关的代码优化工作
- 易于移植(分为前端后端，不同高级语言，不同机器码)
- 使编译程序的结构在逻辑上更为简单明确

### 常见中间语言
- 后缀式
  - 逆波兰式
- 图表示
  - DAG(有向无循环图)，适合代码优化
  - 抽象语法树
- 三地址代码(最终选择)
  - 三元式
  - 四元式(实现的时候直接用，简单又直观)
  - 间接三元式

### 逆波兰式
表达式$E$的定义
- 如果$E$是一个变量或常量、$(E)$，则$E$的后缀式为$E$本身
- 如果$E$是$E_1 op E_2$形式的表达式，其中$op$是任何二元操作符，则$E$的后缀式为$E'_1E'_2op$，其中$E'_1$和$E'_2$分别为$E_1$和$E_2$的后缀式


给出下面表达式的逆波兰表示（后缀式）
- `a+b*(c+d/e)`
- `(A and B) or(not C or D)`
- `-a+b*(-c+d)`
- `(A or B) and (C or not D and E)`
- `a+a*(b-c)+(b-c)*d`
- `b:=-c*a+-c*a`

- `a b c d e / + * +`
- `A B and C not D or or`
- `a - c - d * + b +`
- `A B or C D not E and or and`
- `a b c - * a b c - d * + +`
- `b c a * - c a * - :=`

### 抽象语法树
在语法树中去掉非终结符，比较像中序遍历二叉树
![](./ref/note7-2.PNG)

### DAG
有向无环图
一个内部节点代表一个操作符，孩子是操作数
公共子表达式的节点具有多个父节点(优化)
![](./ref/note7-3.PNG)

### 三地址代码
抽象语法树/DAG的一种线性表示
![](./ref/note7-4.PNG)

#### 种类
- `x:=y op z`
- `x:=op y`
- `x:=y`
- `goto L`
- `if x relop y goto L`或`if a goto L`
- `param x`和`call p, n`以及返回语句`return y`
- `x:=y[i]`及`x[i]:=y`的索引赋值
- `x:=&y`，`x:=*y`和`x:=y`的地址和指针赋值

#### 四元式
`a:=b*(-c)+b*(-c)`

|op|arg1|arg2|result|
|:--:|:--:|:--:|:--:|
|uminus|$c$|&nbsp;|$T_1$|
|$*$|$b$|$T_1$|$T_2$|
|uminus|$c$|&nbsp;|$T_3$|
|$*$|$b$|$T_3$|$T_4$|
|$+$|$T_2$|$T_4$|$T_5$|
|$:=$|$T_5$|&nbsp;|$a$|

每个四元式通过临时变量联系
单目运算只用arg1域，转移语句将目标标号放入result域
arg1、arg2、result通常为指针，指向有关名字的符号表入口

修改容易，临时变量占空间

#### 三元式
`a:=b*(-c)+b*(-c)`

||op|arg1|arg2|
|:--:|:--:|:--:|:--:|
|(0)|uminus|$c$|&nbsp;|
|(1)|$*$|$b$|(0)|
|(2)|uminus|$c$|&nbsp;|
|(3)|$*$|$b$|(2)|
|(4)|$+$|(1)|(3)|
|(5)|assign|$a$|(4)|

修改比较难

#### 间接三元式
平衡上述两个
方便优化，节省空间
间接码表：一张治时期表，按运算的先后次序列出有关**三元式在三元式表中的位置**

## 说明语句的翻译

## 赋值语句的翻译
简单算数表达式及赋值语句翻译为三地址码的翻译模式
- 属性`id.name`表示`id`所代表的名字本身
- 过程`lookup(id.name)`检查是否在符号表中存在相应名字的入口。如果有，则返回一个指向该表项的指针；否则，返回`nil`表示没有找到
- 过程`emit`将生成的三地址语句发送到输出文件中

**还是看课件P28**
每个运算都需要中间代码
没有运算就只有值的传递，规约往上传


### 类型转换
生成的三地址代码
T1 := -C
T2 := T1 + D
T3 := B * T2
A := T3

## 布尔表达式的翻译
布尔表达式：用布尔运算符把布尔量、关系表达式联结起来的式子
- 布尔运算符：`and, or, not`
- 关系运算符：`<, <=, ==, !=, >, >=`

布尔表达式两个基本作用
- 逻辑演算，计算逻辑值
- 控制语句的条件式

难点不在于计算逻辑值，在于用于控制语句的条件式，两者还不一样

### 计算
可以一步步算也可以利用短路偷懒
因此有两种翻译方法

### 数值表示法
- 过程`emit`将三地址代码送到输出文件中
- `nextstat`：给出输出序列中下一条三地址语句的地址索引
- 每产生一条三地址语句后，过程`emit`便把`nextstat`加1

**还是看课件40页**
但是`a<b or c<d and e<f`
每一个比较都要四条语句，最后生成`E or E and E`
就比较复杂

### 条件控制

`if E then S1 else S2`
需要三个跳转语句
跳到真/假，然后真之后要需要跳转到假之后
利用地址跳转而非label，人家也不认识label

### 一遍扫描的转变
想一遍扫描，但是从左到右到then了已经知道要跳转了，但是还不知道跳转去哪，扫了后面了才知道，因此需要**回填机制**
为了回填，需要构造四元式链表，方便回填链上所有的第四区段的同一个值

规约做两件事
- 不知道就把出口挂在链表上，往规约方向传递
- 什么时候知道什么时候回填

翻译
- 采用四元式形式
- 把四元式存入一个数组中，数组下标就代表四元式的标号
- 约定
  - 四元式(jnz, a, -, p) 表示 if a goto p 
  - 四元式(jrop, x, y, p)表示 if x rop y goto p
  - 四元式(j, -, -, p) 表示 goto p

处理链表
为了处理`E.truelist`和`E.falselist` ，引入下列语义变量和过程:
- 变量`nextquad`，它指向下一条将要产生但尚未形成的四元式的地址(标号)。`nextquad`的初值为`1`，每当执行一次`emit`之后，`nextquad`将自动增1。
- 函数`makelist(i)`，它将创建一个仅含i的新链表，其中`i`是四元式数组的一个下标(标号)；函数返回指向这个链的指针。
- 函数`merge(p1,p2)`，把以`p1`和`p2`为链首的两条链合并为一，作为函数值，回送合并后的链首。
- 过程`backpatch(p, t)`，其功能是完成“回填”，把`p`所链接的每个四元式的第四区段都填为t。

布尔表达式的文法
为什么要M定义为空字呢，记录后面E2的入口地址，方便短路运算

$E \rightarrow E_1 or M E_2$没有新语句产生，生产在$E \rightarrow id$...了

$E \rightarrow E_1 and M E_2$
一开始$E_1$上的`truelist`和`falselist`分别至少挂了一个四元式
$E_1$的真出口回填！$E_2$的入口地址

## 控制语句的翻译

P61可不可以用nextquad回填呢，并不可以，这是物理上的下一条语句，并不是程序逻辑的下一条

### while
$S \rightarrow M_1 \quad E \quad do M_2 \quad S_1$
$M_2$记录$S_1$的入口地址
但如果$S$很简单，只对应一条语句，nextlist就只是一个空链表，就不会往回跳转，因此$S$后面强行加一个GOTO语句(有跳转就用不到)

### 分号
P70 107的写法有待考究，错的，可以写个S.nextlist

### 标号与GOTO
先有标号再goto就很好

但是先goto，就需要回填，如果有很多goto就merge起来

## 过程调用的翻译
不重要的
借用一个queue